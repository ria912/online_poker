# Domain 層（学習用ガイド）

このフォルダは、テキサスホールデムにおける「ビジネスルールの中核（ルールの真実の在処）」を表現します。外部I/O（DB/ネットワーク/ログ）やUI都合の値は持たず、ポーカーの状態と不変条件を厳密に扱います。

---

## 設計思想（Principles）

- 単一責任: 各クラスはテーブル/座席/プレイヤー/山札/状態などの1つの概念に責務を限定します。
- 不変条件の保持: スタックが負の値にならない、ホールカードは2枚など、ゲームの基本制約をクラス内部で守ります。
- 集約の一貫性: `GameState` を集約ルートとし、現在のラウンド・ベット状況など「ハンドの真実」を一元管理します。
- 副作用の隔離: ランダム性（シャッフル）やメッセージ送出はサービス層。ドメインは純粋な状態遷移と検証に集中します。
- 表現の明確さ: `enum.py` の列挙で状態/アクション/ポジションを明示し、マジックナンバーを排除します。

---

## ファイル一覧と役割

- `action.py`
  - 値オブジェクト `PlayerAction` を定義。プレイヤーID、アクション種別、金額（任意）を持つ不変データ。

- `deck.py`
  - `Card` と `Deck` を定義。シャッフルとドローのみを提供。`Card.to_treys_int()` で treys 評価器との橋渡しを行います。

- `enum.py`
  - 列挙型を定義。`Round`（PREFLOP/FLOP/TURN/RIVER/SHOWDOWN）、`SeatStatus`（ACTIVE/FOLDED/ALL_IN など）、`ActionType`（FOLD/CHECK/CALL/BET/RAISE/ALL_IN）、`Position`（SB/BB/BTN…）。

- `game_state.py`
  - ハンド全体の状態を表現する集約ルート。現在のラウンド、ボタン/ブラインド位置、現在ベット額、最小レイズ幅、履歴、参加プレイヤー、テーブルなどを保持します。
  - 新ハンド/新ラウンド開始時の初期化メソッドを持ち、状態の整合性を保ちます。

- `player.py`
  - プレイヤーのID・表示名・スタック・AIフラグなど最小情報を保持するエンティティ。

- `seat.py`
  - 各座席の状態（着席者、ホールカード、ポジション、ラウンド内/ハンド内のベット、行動フラグ）を管理します。
  - 新ハンド/新ラウンド用のリセットメソッドを備えます。

- `table.py`
  - テーブル上の共有状態（コミュニティカード、ポット群、座席配列、デッキ）を管理します。
  - 新ハンド/新ラウンド用のリセットメソッドを備えます。
  - 補助的なクエリ（`in_hand_seats`, `active_seats`, `is_round_over` など）で状態判定を提供します。

- `__init__.py`
  - ドメイン公開のエントリーポイント。

---

## 不変条件・整合性ルール（Examples）

- 1プレイヤーのホールカードは常に2枚。
- デッキは重複カードを含まない。
- `SeatStatus.EMPTY` は `player is None` を意味し、`ACTIVE/FOLDED/ALL_IN` は `player is not None` を前提とする。
- `bet_in_round` はラウンド切替時に 0 にリセットされる。
- `GameState.current_bet` はラウンド中の最大投入額（総額）を表す。

---

## 典型的な状態遷移（ハイレベル）

1. 新ハンド開始: `GameState.clear_for_new_hand()` → `Table.reset_for_new_hand()`
2. ディーラーボタン回転・ブラインド設定（サービス側）→ `GameState.dealer_seat_index` 等が更新
3. ホールカード配布（サービス側）→ `Seat.hole_cards` 設定
4. ベットラウンド: `current_bet`/`bet_in_round` を更新しつつ、`Table.is_round_over` が True になれば次ラウンドへ
5. ショーダウン: ハンド評価（サービス側）→ ポット分配（サービス側）

---

## サービス層との境界

- ドメインは「何が正しい状態か」を表現し、操作の原子性や制約を担保します。
- サービス（`services/`）は「いつ・どの順序で行うか」を司り、入出力（プレイヤー操作、配布、通知）をまとめます。
- 例: ブラインド徴収でのスタック減算・`bet_in_round` 加算は、サービス側が現在は実装しています（将来的に `Seat.pay()` を導入して一元化する検討余地あり）。

---

## 拡張指針

- スタック操作の一元化: 将来的に `Seat` へ `pay()`/`refund()` を導入し、スタック整合性を強化。
- ルール差し替え: ブラインド額/最小レイズ幅/テーブルサイズは設定オブジェクト化して `GameState` に注入可能に。
- 役判定の強化: 現在は treys を使用。必要に応じて別評価器へ差し替えしやすいよう `Card` の変換APIは維持。
- ショートハンド/ヘッズアップ特則: `Position` 付与ロジックはサービス側に実装。ドメインでは `Position` 列挙のみ提供。

---

## 学習の観点での読み方

1. まず `enum.py` で用語を把握する。
2. `seat.py` と `table.py` で「個別と集合」の状態を理解する。
3. `game_state.py` で全体のまとめ方（集約）を見る。
4. `deck.py`/`action.py` は小さな値オブジェクトなので最後に確認。

この順で読むと、サービス層のコード（進行/配布/評価）を理解する際の前提がクリアになります。